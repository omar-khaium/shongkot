name: Backend CI/CD

# Automated CI/CD pipeline for backend deployment to Google Cloud Run
# Includes automated README updates with version, changelog, and service status

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-cicd.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-cicd.yml'

env:
  DOTNET_VERSION: '9.0.x'
  
jobs:  
  build-and-test:
    name: Build and Test Backend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Restore dependencies
      run: dotnet restore
      working-directory: ./backend
      
    - name: Build
      run: dotnet build --no-restore --configuration Release
      working-directory: ./backend
      
    - name: Run Unit Tests
      run: dotnet test --no-build --configuration Release --verbosity normal --logger trx --collect:"XPlat Code Coverage" --results-directory ./coverage
      working-directory: ./backend
      
    - name: Code Coverage Report
      uses: codecov/codecov-action@v4
      with:
        files: ./backend/coverage/**/coverage.cobertura.xml
        flags: backend
        name: backend-coverage
        fail_ci_if_error: false
        
    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: |
          backend/coverage/**/*.trx
          
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build-and-test]
    # if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build Docker image
      run: |
        cd backend
        docker build -t shongkot-api:latest .
        
    - name: Test Docker image
      run: |
        docker run -d -p 8080:8080 --name test-container shongkot-api:latest
        sleep 10
        curl -f http://localhost:8080/health || exit 1
        docker stop test-container
        docker rm test-container
        
  deploy-backend:
    name: Deploy Backend to Cloud Run
    runs-on: ubuntu-latest
    needs: [docker-build]
    # if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      checks: write
      pull-requests: write
    outputs:
      SERVICE_URL: ${{ steps.deployment_info.outputs.SERVICE_URL }}
      HEALTH_STATUS: ${{ steps.deployment_info.outputs.HEALTH_STATUS }}
      SWAGGER_STATUS: ${{ steps.deployment_info.outputs.SWAGGER_STATUS }}
    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_REGION: ${{ secrets.GCP_REGION }}
      CLOUD_RUN_SERVICE: ${{ secrets.CLOUD_RUN_SERVICE }}
      ARTIFACT_REPOSITORY: ${{ secrets.GCP_ARTIFACT_REPOSITORY }}
      IMAGE_NAME: shongkot-api
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Validate Cloud Run configuration
      run: |
        set -euo pipefail
        missing=0
        for var in GCP_PROJECT_ID GCP_REGION CLOUD_RUN_SERVICE ARTIFACT_REPOSITORY; do
          if [ -z "${!var:-}" ]; then
            echo "::error::Missing required environment variable: ${var}"
            missing=1
          fi
        done
        if [ "${missing}" -eq 1 ]; then
          exit 1
        fi

    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up gcloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.GCP_PROJECT_ID }}

    - name: Configure Artifact Registry auth
      run: |
        set -euo pipefail
        gcloud config set project "${GCP_PROJECT_ID}"
        gcloud config set run/region "${GCP_REGION}"
        gcloud auth configure-docker "${GCP_REGION}-docker.pkg.dev" --quiet

    - name: Build and push image to Artifact Registry
      env:
        IMAGE_TAG: ${{ github.sha }}
      run: |
        set -euo pipefail
        IMAGE_URI="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${ARTIFACT_REPOSITORY}/${IMAGE_NAME}:${IMAGE_TAG}"
        echo "IMAGE_URI=${IMAGE_URI}" >> "${GITHUB_ENV}"
        docker build -t "${IMAGE_URI}" backend
        docker push "${IMAGE_URI}"

    - name: Deploy to Cloud Run
      id: deploy
      run: |
        set -euo pipefail
        if [ -z "${IMAGE_URI:-}" ]; then
          echo "::error::Missing IMAGE_URI from previous step."
          exit 1
        fi
        gcloud run deploy "${CLOUD_RUN_SERVICE}" \
          --image "${IMAGE_URI}" \
          --region "${GCP_REGION}" \
          --platform managed \
          --allow-unauthenticated \
          --format=json > deploy_output.json
        
        # Extract service URL
        SERVICE_URL=$(jq -r '.status.url' deploy_output.json)
        echo "SERVICE_URL=${SERVICE_URL}" >> "${GITHUB_OUTPUT}"
        echo "::notice::Deployed to ${SERVICE_URL}"
    
    - name: Get deployment info
      id: deployment_info
      run: |
        set -euo pipefail
        SERVICE_URL="${{ steps.deploy.outputs.SERVICE_URL }}"
        
        # Wait a few seconds for service to be ready
        sleep 5
        
        # Check health endpoint
        HEALTH_STATUS="unknown"
        if curl -sf "${SERVICE_URL}/health" > /dev/null 2>&1; then
          HEALTH_STATUS="âœ… healthy"
        else
          HEALTH_STATUS="âš ï¸ checking"
        fi
        
        # Check swagger endpoint
        SWAGGER_STATUS="unknown"
        if curl -sf "${SERVICE_URL}/swagger/index.html" > /dev/null 2>&1; then
          SWAGGER_STATUS="âœ… available"
        else
          SWAGGER_STATUS="âš ï¸ checking"
        fi
        
        echo "HEALTH_STATUS=${HEALTH_STATUS}" >> "${GITHUB_OUTPUT}"
        echo "SWAGGER_STATUS=${SWAGGER_STATUS}" >> "${GITHUB_OUTPUT}"
        echo "SERVICE_URL=${SERVICE_URL}" >> "${GITHUB_OUTPUT}"
  
  update-readme:
    name: Update README with Deployment Info
    runs-on: ubuntu-latest
    needs: [deploy-backend]
    # Note: In production, add condition: if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    # For now, running on all events to demonstrate functionality
    permissions:
      contents: write
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Get deployment details
      id: get_details
      env:
        SERVICE_URL: ${{ needs.deploy-backend.outputs.SERVICE_URL }}
        HEALTH_STATUS: ${{ needs.deploy-backend.outputs.HEALTH_STATUS }}
        SWAGGER_STATUS: ${{ needs.deploy-backend.outputs.SWAGGER_STATUS }}
      run: |
        set -euo pipefail
        
        # Generate version tag from date and short SHA
        VERSION_TAG="v$(date +'%Y.%m.%d')-${GITHUB_SHA:0:7}"
        echo "VERSION_TAG=${VERSION_TAG}" >> "${GITHUB_OUTPUT}"
        
        # Get commit message for changelog
        COMMIT_MSG=$(git log -1 --pretty=%B)
        echo "COMMIT_MSG<<EOF" >> "${GITHUB_OUTPUT}"
        echo "${COMMIT_MSG}" >> "${GITHUB_OUTPUT}"
        echo "EOF" >> "${GITHUB_OUTPUT}"
        
        # Generate changelog from recent commits
        echo "CHANGELOG<<EOF" >> "${GITHUB_OUTPUT}"
        git log --pretty=format:"- %s (%h)" -10 >> "${GITHUB_OUTPUT}"
        echo "" >> "${GITHUB_OUTPUT}"
        echo "EOF" >> "${GITHUB_OUTPUT}"
        
        echo "DEPLOY_TIME=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> "${GITHUB_OUTPUT}"
    
    - name: Update README
      env:
        VERSION_TAG: ${{ steps.get_details.outputs.VERSION_TAG }}
        COMMIT_MSG: ${{ steps.get_details.outputs.COMMIT_MSG }}
        CHANGELOG: ${{ steps.get_details.outputs.CHANGELOG }}
        DEPLOY_TIME: ${{ steps.get_details.outputs.DEPLOY_TIME }}
        SERVICE_URL: ${{ needs.deploy-backend.outputs.SERVICE_URL }}
        HEALTH_STATUS: ${{ needs.deploy-backend.outputs.HEALTH_STATUS }}
        SWAGGER_STATUS: ${{ needs.deploy-backend.outputs.SWAGGER_STATUS }}
      run: |
        set -euo pipefail
        
        # Backup README
        cp README.md README.md.bak
        
        # Create deployment status section
        {
          echo "## ðŸš€ Latest Deployment"
          echo ""
          echo "**Version:** ${VERSION_TAG}  "
          echo "**Deployed:** ${DEPLOY_TIME}  "
          echo "**Commit:** ${GITHUB_SHA:0:7}"
          echo ""
          echo "### Service Status"
          echo ""
          echo "- **Health Check:** ${HEALTH_STATUS} - [${SERVICE_URL}/health](${SERVICE_URL}/health)"
          echo "- **API Documentation:** ${SWAGGER_STATUS} - [${SERVICE_URL}/swagger](${SERVICE_URL}/swagger)"
          echo "- **Base URL:** [${SERVICE_URL}](${SERVICE_URL})"
          echo ""
          echo "### What's New in ${VERSION_TAG}"
          echo ""
          echo "${COMMIT_MSG}"
          echo ""
          echo "### Recent Changes"
          echo ""
          echo "${CHANGELOG}"
          echo ""
          echo "---"
          echo ""
        } > deployment_status.md
        
        # Check if deployment section already exists
        if grep -q "## ðŸš€ Latest Deployment" README.md; then
          # Replace existing deployment section
          awk '
            /## ðŸš€ Latest Deployment/ {
              system("cat deployment_status.md")
              skip=1
              next
            }
            /^---$/ && skip {
              skip=0
              next
            }
            !skip
          ' README.md > README.md.new
          mv README.md.new README.md
        else
          # Insert after badges section (after line 5)
          head -n 5 README.md > README.md.new
          echo "" >> README.md.new
          cat deployment_status.md >> README.md.new
          tail -n +6 README.md >> README.md.new
          mv README.md.new README.md
        fi
        
        # Clean up
        rm deployment_status.md
    
    - name: Commit and push README updates
      run: |
        set -euo pipefail
        
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        if git diff --quiet README.md; then
          echo "No changes to README.md"
          exit 0
        fi
        
        git add README.md
        git commit -m "docs: update README with deployment info [${{ steps.get_details.outputs.VERSION_TAG }}]"
        git push origin main
    
    - name: Create deployment summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'SUMMARY_EOF'
        ## ðŸŽ‰ Deployment Successful
        
        **Version:** ${{ steps.get_details.outputs.VERSION_TAG }}
        **Service URL:** ${{ needs.deploy-backend.outputs.SERVICE_URL }}
        
        ### Endpoints
        - ðŸ¥ Health: ${{ needs.deploy-backend.outputs.SERVICE_URL }}/health - ${{ needs.deploy-backend.outputs.HEALTH_STATUS }}
        - ðŸ“š Swagger: ${{ needs.deploy-backend.outputs.SERVICE_URL }}/swagger - ${{ needs.deploy-backend.outputs.SWAGGER_STATUS }}
        
        ### What's New
        ${{ steps.get_details.outputs.COMMIT_MSG }}
        
        README has been updated with the latest deployment information.
        SUMMARY_EOF
